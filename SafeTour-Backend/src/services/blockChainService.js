const { ethers } = require("ethers");

// 1. IMPORT THE CONTRACT ABI
// This is the JSON file that describes how to interact with your smart contract.
// It's generated by Hardhat when you compile the contract.
const TouristIdABI = require('../../../SafeTour-Blockchain/artifacts/contracts/TouristId.sol/TouristId.json').abi;

// ===================================================================================
//  SINGLETON BLOCKCHAIN CONNECTION
//  This section initializes the connection to the blockchain. It runs only once
//  when the server starts, making it highly efficient.
// ===================================================================================
let provider;
let wallet;
let touristIdContract;

try {
    // --- 2. Input Validation ---
    // Check if all required environment variables are present.
    const requiredEnvVars = ['SEPOLIA_RPC_URL', 'BACKEND_WALLET_PRIVATE_KEY', 'CONTRACT_ADDRESS'];
    for (const varName of requiredEnvVars) {
        if (!process.env[varName]) {
            throw new Error(`CRITICAL: Environment variable ${varName} is not set!`);
        }
    }

    // --- 3. Initialize Provider and Wallet ---
    // The provider is our read-only connection to the blockchain.
    // FIX: Updated to ethers v6 syntax. 'providers' namespace is removed.
    provider = new ethers.JsonRpcProvider(process.env.SEPOLIA_RPC_URL);

    // The wallet represents our backend's identity on the blockchain.
    // It's created from the private key and connected to the provider.
    wallet = new ethers.Wallet(process.env.BACKEND_WALLET_PRIVATE_KEY, provider);

    // --- 4. Initialize Contract Instance ---
    // This is the object we will use to call our smart contract's functions.
    // It combines the contract's address, its ABI (the "how-to" guide), and our wallet (the "who").
    touristIdContract = new ethers.Contract(process.env.CONTRACT_ADDRESS, TouristIdABI, wallet);

    console.log(`âœ… Blockchain service initialized. Connected to contract at: ${touristIdContract.address}`);

} catch (error) {
    console.error("ðŸš¨ FAILED TO INITIALIZE BLOCKCHAIN SERVICE:", error.message);
    // Exit the process if the blockchain connection cannot be established.
    // This is a critical failure, and the server cannot function without it.
    process.exit(1);
}
// ===================================================================================


/**
 * @desc    Calls the smart contract to register a new tourist and issue a Digital ID.
 * @param   {string} touristAddress The public wallet address of the tourist.
 * @param   {string} kycHash A secure SHA-256 hash of the tourist's KYC data.
 * @returns {Promise<string>} The transaction hash of the successful registration.
 * @throws  Will throw an error if the blockchain transaction fails.
 */
async function issueDigitalId(touristAddress, kycHash) {
    try {
        console.log(`[Blockchain] Attempting to issue ID for ${touristAddress}...`);
        
        // --- 5. Call the Smart Contract Function ---
        // This sends a transaction to the blockchain to execute the 'registerTourist' function.
        // Our 'wallet' instance automatically signs this transaction.
        const tx = await touristIdContract.registerTourist(touristAddress, kycHash, {
             // You can explicitly set gas price and limit for more control in production
             // gasLimit: ethers.utils.parseUnits("100000", "gwei"), 
        });

        console.log(`[Blockchain] Transaction sent. Hash: ${tx.hash}. Waiting for confirmation...`);

        // --- 6. Wait for the Transaction to be Mined ---
        // The '.wait()' function pauses execution until the transaction has been included
        // in a block on the blockchain, ensuring it's confirmed.
        await tx.wait(1); // Wait for 1 block confirmation.

        console.log(`[Blockchain] Transaction confirmed for ${touristAddress}.`);
        
        return tx.hash;

    } catch (error) {
        // --- 7. Robust Error Handling ---
        console.error(`[Blockchain Error] Failed to issue ID for ${touristAddress}:`, error.reason || error.message);
        // Re-throw the error so the calling function (in the admin route) can handle it
        // and send an appropriate HTTP response.
        throw new Error("Blockchain transaction failed.");
    }
}

// Export the functions that other parts of the application will use.
module.exports = {
    issueDigitalId
};

